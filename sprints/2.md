## **SPRINT 2: Autenticación Backend-Centric (Registro y Setup Inicial)**

**Objetivo del Sprint:** Implementar los endpoints de registro de usuarios (Owner, Employee, Customer) que interactúan con Supabase Auth y la tabla `user_profiles` del backend, asegurando la atomicidad y las restricciones de seguridad adecuadas.

**3\. Autenticación y Sistema de Roles**

*   **3.1. Tarea: Integrar el cliente Supabase en FastAPI y configurar la validación JWT.**
    *   **Prompt para el Agente:** "Crea una instancia global (o dependencia) del cliente Supabase en FastAPI, utilizando las claves `anon_key` y `service_role_key` de forma segura. Implementa una dependencia de FastAPI (`Depends`) que se encargue de:
        1.  Extraer el JWT del encabezado `Authorization: Bearer`.
        2.  Validar el JWT usando `python-jose` o la lógica de validación de Supabase (asegurando que el token esté firmado por Supabase y no haya expirado).
        3.  Extraer el `user_id` (sub) del JWT validado.
        4.  Retornar el `user_id` para su uso en otras dependencias o lógica de negocio.
        Implementa un modelo Pydantic `User` que contenga al menos el `id` (UUID) del usuario y un `is_authenticated` booleano."
    *   **Entregable:** Dependencia de FastAPI `get_current_user` (o similar) que valide JWTs de Supabase y extraiga el `user_id`.
    *   **Testing:** Crear un endpoint de prueba `/protected` que use esta dependencia. Enviar una solicitud con un JWT válido y otra con uno inválido/expirado para verificar las respuestas correctas (200 OK vs 401 Unauthorized).
*   **3.2. Tarea: Crear los endpoints de registro de usuarios (`/auth/register/{role}`).**
    *   **Prompt para el Agente:** "Implementa los siguientes endpoints POST en el router de autenticación (`src/api/auth.py`):

        *   **`POST /auth/register/owner`**
            *   **Descripción:** Permite el registro del primer propietario del sistema.
            *   **Requisitos de Seguridad CRÍTICA:**
                1.  **Restricción de Acceso:** Este endpoint **NO DEBE SER PÚBLICO**. Requiere un encabezado `X-Admin-Secret` con un valor pre-configurado (ej., variable de entorno). Si el `X-Admin-Secret` es incorrecto, responder con 403 Forbidden.
                2.  **Unicidad del Propietario:** Antes de proceder, verificar si ya existe un usuario con `role='owner'` en la tabla `user_profiles`. Si existe, responder con 409 Conflict.
            *   **Lógica:**
                1.  Recibir email y password (Pydantic `OwnerRegisterSchema`).
                2.  Llamar a `supabase_client.auth.admin.create_user()` con el email y password.
                3.  Si la creación en `auth.users` es exitosa:
                    *   Crear un nuevo `business` en `public.businesses` (generando un `access_code` único).
                    *   Insertar una entrada en `public.user_profiles` con el `id` del usuario recién creado, `role='owner'` y el `business_id` del nuevo negocio.
                    *   **Manejo de Transacciones/Atomicidad:** Implementar un bloque `try-except-finally` robusto. Si la creación del `business` o `user_profiles` falla, **eliminar el usuario de `auth.users`** utilizando `supabase_client.auth.admin.delete_user()` para evitar inconsistencias.
                4.  Devolver los tokens de sesión (Access Token, Refresh Token) obtenidos de `supabase_client.auth.admin.invite_user_by_email` o `create_user` si Supabase los retorna directamente, o realizar un `signInWithPassword` si es necesario para obtenerlos.
            *   **Salida:** HTTP 201 Created con el usuario (sin password), Access Token y Refresh Token.
        *   **`POST /auth/register/employee`**
            *   **Descripción:** Permite a un propietario (o un empleado autorizado) registrar un nuevo empleado.
            *   **Autorización:** Este endpoint debe estar protegido por la dependencia de validación JWT (del paso 3.1) y una nueva dependencia `RoleChecker(required_roles=['owner'])` para asegurar que solo los propietarios autenticados puedan acceder.
            *   **Lógica:**
                1.  Recibir email y password (Pydantic `EmployeeRegisterSchema`).
                2.  Obtener el `user_id` y `business_id` del propietario autenticado desde el JWT validado y `user_profiles`.
                3.  Llamar a `supabase_client.auth.admin.create_user()` para el nuevo empleado.
                4.  Si la creación en `auth.users` es exitosa:
                    *   Insertar una entrada en `public.user_profiles` con el `id` del nuevo usuario, `role='employee'` y el `business_id` del propietario que lo registró.
                    *   **Manejo de Transacciones/Atomicidad:** Si la creación del `user_profiles` falla, **eliminar el usuario de `auth.users`**.
                5.  Devolver los tokens de sesión del nuevo empleado.
            *   **Salida:** HTTP 201 Created con el nuevo empleado, Access Token y Refresh Token.
        *   **`POST /auth/register/customer`**
            *   **Descripción:** Permite el auto-registro de clientes. Puede ser llamado por un usuario no autenticado.
            *   **Lógica:**
                1.  Recibir email y password (Pydantic `CustomerRegisterSchema`).
                2.  Llamar a `supabase_client.auth.sign_up()` (para auto-registro) o `supabase_client.auth.admin.create_user()` (si un admin/owner lo registra). Si es `sign_up`, Supabase enviará un correo de confirmación.
                3.  Si la creación en `auth.users` es exitosa:
                    *   Insertar una entrada en `public.user_profiles` con el `id` del nuevo usuario, `role='customer'`.
                    *   Opcionalmente, si la solicitud viene de un `owner`/`employee` autenticado, asociar el `business_id` del solicitante al cliente (dependiendo de la lógica de negocio si un cliente puede pertenecer a varios negocios).
                    *   **Manejo de Transacciones/Atomicidad:** Si la creación del `user_profiles` falla, **eliminar el usuario de `auth.users`** (si se usó `admin.create_user`). Para `sign_up`, Supabase lo maneja, pero si el perfil falla, el usuario existiría pero sin rol, lo cual es un estado indeseado y debe ser detectado.
                4.  Devolver los tokens de sesión del nuevo cliente (si `sign_up` devuelve los tokens o si se usó `admin.create_user`).
            *   **Salida:** HTTP 201 Created con el nuevo cliente, Access Token y Refresh Token.

    *   **Entregable:** Implementación de los tres endpoints de registro en FastAPI con las validaciones y lógicas de atomicidad.
    *   **Testing:**
        *   **Unitarias:** Pruebas para la lógica de atomicidad (simular fallos en la BD y verificar la eliminación en `auth.users`).
        *   **Integración (con `httpx`):**
            *   Probar `POST /auth/register/owner` con `X-Admin-Secret` correcto e incorrecto.
            *   Probar `POST /auth/register/owner` intentando crear un segundo owner.
            *   Probar `POST /auth/register/employee` con un owner autenticado y con un usuario no autorizado.
            *   Probar `POST /auth/register/customer` como auto-registro.
            *   Verificar que `auth.users` y `public.user_profiles` se actualizan correctamente para cada rol.
            *   Verificar que los Access y Refresh Tokens son retornados y parecen válidos (estructura JWT).

---