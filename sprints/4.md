## **SPRINT 4: Sistema de Reservas (Núcleo)**

**Objetivo del Sprint:** Implementar la lógica fundamental para la gestión de reservas de citas, incluyendo la validación de horarios y la prevención de "double-booking".

*   **1.1. Tarea: Diseñar e implementar la API de reservas (`appointments`).**
    *   **Prompt para el Agente:** "Diseña el modelo de base de datos para `appointments` (fecha, hora de inicio, hora de fin, `customer_id`, `employee_id`, `service_id`, `business_id`, estado, etc.). Crea los esquemas Pydantic para crear, leer, actualizar y listar citas. Desarrolla los endpoints CRUD para `appointments` en FastAPI, asegurando que `customer_id`, `employee_id`, `service_id` y `business_id` sean correctamente asociados y validados."
    *   **Entregable:** Modelos de BD, esquemas Pydantic y endpoints CRUD para `appointments`.
    *   **Testing:** Pruebas CRUD básicas con diferentes roles (customer, employee, owner) y validación de la asociación a `business_id`.
*   **1.2. Tarea: Desarrollar la lógica de validación de horarios.**
    *   **Prompt para el Agente:** "Implementa la lógica en la capa de servicios para validar que una nueva reserva de cita no entra en conflicto con:
        1.  Los horarios de operación definidos para el `business`.
        2.  La disponibilidad del `employee` asignado (horario de trabajo, otras citas, etc.).
        Esta lógica debe ejecutarse antes de cualquier intento de inserción en la base de datos."
    *   **Entregable:** Funciones de validación de horarios en la capa de servicios.
    *   **Testing:** Pruebas unitarias para la lógica de validación con escenarios de conflicto y no conflicto (ej., cita fuera de horario del salón, cita superpuesta con otra del empleado).
*   **1.3. Tarea: Implementar la lógica de "locks" para prevenir el `double-booking`.**
    *   **Prompt para el Agente:** "Para prevenir que dos clientes intenten reservar la misma franja horaria para el mismo empleado simultáneamente, implementa un mecanismo de bloqueo a nivel de base de datos. Considera:
        1.  **Bloqueo Pesimista (SQL):** Utilizar `SELECT FOR UPDATE` en la transacción de creación de la cita para bloquear temporalmente las filas relevantes (`employee` y franjas horarias).
        2.  **Constraints de Base de Datos:** Explorar si es posible una constraint `EXCLUDE` en PostgreSQL para rangos de tiempo (PostgreSQL `pg_trgm` o `btree_gist` para `OVERLAPS` con `daterange`/`tsrange` types) para que la base de datos fuerce la unicidad de las franjas horarias por empleado. Esto sería lo más robusto.
    *   **Entregable:** Implementación de la lógica de bloqueo en la creación de citas.
    *   **Testing:** **Pruebas de concurrencia** utilizando múltiples clientes de prueba (`httpx` asíncrono) que intenten reservar la misma franja horaria simultáneamente. Verificar que solo una operación es exitosa y las otras fallan con un error apropiado.
*   **1.4. Tarea: Crear endpoints para que el `owner` y `employee` gestionen su disponibilidad.**
    *   **Prompt para el Agente:** "Implementa endpoints que permitan a los `owners` y `employees` marcar bloques de tiempo como 'no disponibles' (ej., para descansos, reuniones o días libres). Esto debe afectar la lógica de validación de horarios de las citas."
    *   **Entregable:** Endpoints para gestionar la disponibilidad de empleados y la integración con la lógica de validación de reservas.
    *   **Testing:** Probar la marcación de disponibilidad ON/OFF y verificar que las citas intentadas en esos bloques de tiempo sean rechazadas.
