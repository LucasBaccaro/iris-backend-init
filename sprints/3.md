## **SPRINT 3: Autenticación Avanzada y Endpoints CRUD Base**

**Objetivo del Sprint:** Completar el sistema de autenticación con endpoints de login y refresco de tokens, implementar la lógica de autorización granular basada en roles y `business_id` (RoleChecker), y desarrollar los primeros endpoints CRUD básicos para las entidades principales.

**3\. Autenticación y Sistema de Roles (Continuación)**

*   **3.3. Tarea: Crear los endpoints de autenticación (`/auth/login`, `/auth/refresh_token`).**
    *   **Prompt para el Agente:** "Implementa los siguientes endpoints POST en el router de autenticación (`src/api/auth.py`):

        *   **`POST /auth/login`**
            *   **Descripción:** Permite a un usuario existente iniciar sesión.
            *   **Lógica:**
                1.  Recibir email y password (Pydantic `LoginSchema`).
                2.  Llamar a `supabase_client.auth.sign_in_with_password()`.
                3.  Si la autenticación es exitosa:
                    *   Obtener el `user_id` del usuario autenticado.
                    *   Consultar `public.user_profiles` para obtener el `role` y `business_id` asociados a ese `user_id`.
                4.  Devolver el Access Token (JWT), Refresh Token (ambos de Supabase), y la información de `role` y `business_id` del usuario al frontend.
            *   **Salida:** HTTP 200 OK con el Access Token, Refresh Token, `user_id`, `role`, `business_id`.
        *   **`POST /auth/refresh_token`**
            *   **Descripción:** Permite al frontend obtener un nuevo Access Token cuando el actual expira, utilizando el Refresh Token.
            *   **Lógica:**
                1.  Recibir el Refresh Token del frontend (Pydantic `RefreshTokenSchema`).
                2.  Llamar a `supabase_client.auth.refresh_session()` con el Refresh Token.
                3.  Si el refresco es exitoso:
                    *   Devolver el **nuevo Access Token** y el **nuevo Refresh Token** (si Supabase los rota) al frontend.
            *   **Salida:** HTTP 200 OK con el nuevo Access Token y Refresh Token.
    *   **Entregable:** Implementación de los endpoints `login` y `refresh_token`.
    *   **Testing:**
        *   **Integración:**
            *   Probar `POST /auth/login` con credenciales correctas e incorrectas, verificando las respuestas (200 OK con tokens vs 400/401).
            *   Probar `POST /auth/refresh_token` con un refresh token válido e inválido/expirado, verificando las respuestas y la rotación de tokens.
            *   Simular el ciclo completo: login -> usar Access Token -> esperar expiración (o forzarla con un token de vida muy corta) -> usar Refresh Token -> usar el nuevo Access Token.

*   **3.4. Tarea: Implementar la lógica de roles y permisos granular (`RoleChecker`).**
    *   **Prompt para el Agente:** "Crea una dependencia de FastAPI (`src/core/auth.py`) llamada `RoleChecker` que:
        1.  Tome como argumento una lista de `required_roles` (ej., `['owner', 'employee']`).
        2.  Utilice la dependencia de validación JWT (del paso 3.1) para obtener el `user_id` del usuario autenticado.
        3.  Consulta la tabla `public.user_profiles` para obtener el `role` y `business_id` de ese `user_id`.
        4.  Si el `role` del usuario no está en `required_roles`, eleva una `HTTPException(status_code=403, detail="Not authorized")`.
        5.  Si el rol es válido, devuelve el objeto `User` enriquecido con `role` y `business_id`.
        Crea otra dependencia `get_user_business_id` que utilice `RoleChecker` y retorne únicamente el `business_id` del usuario actual."
    *   **Entregable:** Dependencias `RoleChecker` y `get_user_business_id` funcionales.
    *   **Testing:**
        *   **Unitarias:** Pruebas para `RoleChecker` con diferentes roles y requisitos (ej., usuario 'customer' intentando acceder a un endpoint solo para 'owner').
        *   **Integración:** Aplicar `RoleChecker` a un endpoint de prueba y verificar el acceso con usuarios de diferentes roles y `business_id`.

**4\. Endpoints CRUD Base**

*   \[ \] **Tarea:** Desarrollar los endpoints **CRUD** (Crear, Leer, Actualizar, Borrar) para `businesses`, `employees`, `services`, `promotions`.
    *   **Prompt para el Agente:** "Para cada una de las entidades (`businesses`, `employees`, `services`, `promotions`):
        1.  **Modelos Pydantic:** Crea los esquemas Pydantic (`src/schemas/`) para la validación de entrada (Crear, Actualizar) y la serialización de salida (Leer).
        2.  **Capa de Servicios:** Implementa una capa de servicios (`src/services/`) que contenga la lógica de negocio y las interacciones con la base de datos (utilizando el cliente Supabase para ejecutar consultas SQL o funciones). Esta capa debe ser agnóstica a FastAPI.
        3.  **Routers de FastAPI:** Crea routers dedicados (`src/api/`) con los endpoints HTTP para las operaciones CRUD.
        4.  **Autorización (RoleChecker):** Protege cada endpoint CRUD con la dependencia `RoleChecker` y, donde sea apropiado, con `get_user_business_id` para asegurar que:
            *   Solo los `owners` pueden crear/actualizar/borrar `businesses`.
            *   Los `employees` pueden leer información de su `business`.
            *   Las operaciones sobre `employees`, `services`, `promotions` estén vinculadas al `business_id` del usuario autenticado.
            *   **Filtrado por `business_id`:** Asegura que todas las operaciones de lectura, actualización y borrado de `employees`, `services`, `promotions` solo afecten a recursos que pertenecen al `business_id` del usuario autenticado.
        5.  **Generación de `access_code`:** Al crear un nuevo `business`, implementa la lógica en la capa de servicios para generar un `access_code` único (ej., un UUID corto o string alfanumérico aleatorio) y asociarlo al negocio.
    *   **Entregable:** Conjunto completo de endpoints CRUD para las entidades especificadas, con validación Pydantic, lógica de servicios y autorización `RoleChecker` aplicada.
    *   **Testing:**
        *   **Unitarias:** Pruebas para la capa de servicios (ej., verificar que las funciones de creación/actualización manipulan los datos correctamente sin depender de FastAPI).
        *   **Integración:**
            *   **Creación:** Probar la creación de cada entidad por un usuario autorizado, verificando la persistencia y la asignación del `business_id`. Verificar que el `access_code` se genera para los `businesses`.
            *   **Lectura:** Probar la lectura de colecciones y elementos individuales, verificando que los resultados se filtran por `business_id` del usuario y que los usuarios no pueden ver datos de otros negocios.
            *   **Actualización:** Probar la actualización de datos por usuarios autorizados, verificando que solo pueden modificar recursos de su propio negocio.
            *   **Borrado:** Probar el borrado de datos por usuarios autorizados, verificando la eliminación y las restricciones de integridad.
            *   **Pruebas de Autorización:** Intentar realizar operaciones CRUD con usuarios no autorizados o con el `business_id` incorrecto, verificando las respuestas 403 Forbidden.

---